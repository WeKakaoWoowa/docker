# 3장 컨테이너 실전 구축 및 배포

## 컨테이너 1개에 하나의 관심사

컨테이너의 역활을 정할때 하나의 프로세스 단위가 아닌 한가지 역할이나 문제 영역(도메인)에만 집중해야 한다.
지나치게 컨테이너 1개 = 프로세스 1개 원칙을 고수하면, 도커를 사용하는 이유인 배포 편의성을 해칠 수 있다.

## 컨테이너의 이식성

도커의 큰 장점은 그 이식성에 있다. 기본적으로 도커가 설치된 환경이라면 어떤 호스트 운영체제와 플랫폼, 온프레미스 및 클라우드 환경에서도 그대로 동작한다.
하지만 몇가지 예외가 존재한다.

### 커널 및 아키텍처의 차이

도커에서 사용되는 컨테이너형 가상화 기술은 호스트 운영체제와 커널 리소스를 공유한다. 이는 사실상 도커 컨테이너를 실행 하려면 호스트가 특정 CPU 아키텍처 혹은 운영체제를 사용해야한다는 의미다.

ex)

1. 라즈베리 파이 같은 arm계열의 armv7I아키텍처를 채용한 플랫폼에서는 인텔의 x86_64아키텍처에서 빌드한 도커 컨테이너를 실행 할 수 없음.
2. 윈도우 서버 기반 이미지는 리눅스나 macOS등의 플랫폼에서는 실행 할 수 없음

### 라이브러리와 동적 링크 문제

동적 링크를 사용한 애플리케이션을 도커에서 사용하는 경우, 기존 호스트에서 빌드 했을때 정상적으로 빌드가 되었지만 다른 호스트에서 빌드 했을때 다른 버전 또는 다른 표준 라이브러리가 다운 받아져서 정상적으로 빌드가 되지 않을 수 있다.

해결방안

- 정적 링크 사용 (실행 파일의 크기가 커진다는 단점이 있음)
- 모든 빌드 프로세스를 실행하는 도커 컨테이너를 만들고 그 안에서 애플리케이션을 빌드
- multi-stage builds

## 도커 친화적인 애플리케이션

### 환경 변수 활용

환경변수를 이용하면 어플리케이션의 재사용성과 유연성을 가지도록 만들 수 있다.

이를 활용하면 도커 환경에 맞게 외부에서 동작을 제어 할 수 있다.

도커 컨테이너 내부 애플리케이션의 동작을 제어하는 방법 (책에서는 애플리케이션 동작을 환경변수로 제어 하는 방법을 추천함.)

- 실행 시 인자
- 설정 파일
- 애플리케이션 동작을 환경 변수로 제어
- 설정 파일에 환경 변수를 포함

#### 실행 시 인자를 사용

도커에는 CMD 나 ENTRYPOINT같은 인스트럭션을 사용해 컨테이너를 실행할 때 사용할 명령을 정의해 둘 수 있다.

실행 시 인자가 너무 많이지면 애플리케이션에서 인자를 내부 변수로 맵핑해주는 처리가 복잡해지거나 CMD 및 ENTRYPOINT 인스트럭션 내용을 관리하기가 어려워질 수 있다는 단점이 있다.

#### 설정 파일 사용

실행할 애플리케이션에 dev, prod와 같은 환경 이름을 부여하고, 그에 따라 설정 파일을 바꿔가며 사용하는 방식.

이를 컨테이너에서 이용하려면 애플리케이션의 도커 이미지를 각 설정 파일 별로 만들어 두는 방법을 생각해 볼 수 있다.

그러나 도커의 장점은 언제, 어떤 환경에서도 배포 가능하다는점이다. 이렇게 하게 되면 도커 이미지가 특정환경으로 제한되기때문에 도커의 이식성을 해치게된다.

또한 설정파일을 바꾸게되면 이미지를 다시 빌드해야한다.

#### 애플리케이션 동작을 환경 변수로 제어

환경 변수를 사용하면 매번 이미지를 다시 빌드하지 않고 컨테이너를 다시 시작하기만 하면 된다.

환경변수는 애플리케이션과 별도의 리파지토리를 통해 관리하는것이 일반적이며, 컴포즈를 사용하는 경우 docker-compose.yml파일의 env속성에 기술해 관리한다.

#### 설정 파일에 환경 변수를 포함

환경 변수의 정점과 설정 파일의 장점을 모두 취하는 방법.

환경별 설정 파일을 애플리케이션에 포함하는 대신, 설정 파일 템플릿에 환경변수를 포함.

ex) Spring Framework properties 파일

```shell
db.driverClass=${DB_DRIVER_CLASS:com.mysql.jdbc.Driver
db.jdbcUrl=${DB_JDBC_URL}
```

모든 애플리케이션 프레임워크가 이런 기능을 지원 하는것은 아니다. 각 프레임워크마다 최선인 방법을 선택하면 될듯.

## 퍼시스턴스 데이터를 다루는 방법

기본적으로 도커 컨테이너가 실행 중에 작성 혹은 수정된 파일은 컨테이너가 파기될 때 호스트에서 함께 삭제된다.

해당 파일들을 유지하고 싶다면 호스트 쪽 파일 시스템에 마운트 시켜야한다. 이런 경우에 사용되는 것이 **데이터 볼륨**이다.

### 데이터 볼륨

호스트와 컨테이너 사이의 디렉터리 공유 및 재사용 기능 제공.

주의: 호스트 안의 특정 경로에 의존성이 생기기 때문에 호스트 쪽 데이터 볼륨을 잘못 다루면 애플리케이션에 부정적 영향을 미칠 수 있다.

```shell
docker container run [options] -v 호스트_디렉터리:컨테이너_디렉터리 리포지토리명[:태그] [명령] [명령인자]

ex) docker container run -d -p 8080:8080 -v ${PWD}/jenkins_home:/var/jenkins_home jenkins:latest
```

- ${PWD} 에 자동적으로 현재 디렉토리 path가 들어간다. ( 확인하려면 echo ${PWD} )

### 데이터 볼륨 컨테이너

데이터를 저장하는 것만이 목적인 컨테이너.

컨테이너 간에 디렉터리를 공유.

데이터 볼륨 컨테이너의 볼륨은 도커에서 관리하는 영역인 호스트 머신의 /var/lib/docker/volumes/ 아래 위치한다.

이 방식은 도커가 관리하는 디렉터리 영역에만 영향을 미치기 때문에, 호스트-컨테이너 데이터 볼륨과 비교하면 호스트 머신이 컨테이너에 미치는 영향을 최소한으로 억제한다.

데이터 볼륨 컨테이너가 직접 볼륨을 다뤄주므로 필요로 하는 컨테이너가 사용할 호스트 디렉터리를 알 필요가 없고 디렉터리를 제공하는 데이터 볼륨 컨테이너만 지정하면 된다.

## 컨테이너 배치 전략

실무에서 사용 할 때에는 많은 트래픽을 처리하기 위해 컨테이너를 단일 도커 호스트에만 배치하는것이 아니라 여러 컨테이너가 각기 다른 호스트에 배치된다.

이를 위해 컨테이너 오케스트레이션 도구를 사용해야하며 대표적으로 **도커스웜**과 **쿠버네티스가 있다.**

### 도커스웜

도커 스웜은 여러 도커 호스트를 클러스터로 묶어주는 컨테이너 오케스트레이션 도구의 한 종류다. (현재는 도커에 내장돼 스웜 모드를 활성화하면 사용할 수 있다.)

|이름|역할|명령어|
|---|---|----|
|컴포즈|여러 컨테이너로 구성된 도커 애플리케이션을 관리 (주로 단일 호스트)||
|스웜|클러스터 구축 및 관리 (주로 멀티 호스트)||
|서비스|스웜에서 클러스터 안의 서비스 (컨테이너 하나 이상의 집합)를 관리||
|스택|스웜에서 여러개의 서비스를 합한 전체 애플리케이션을 관리||

#### 여러 대의 도커 호스트로 스웜 클러스터 구성하기

- registry x 1
- manager x 1
- worker x 3

registry

도커 허브나 별도로 사전 구축한 인하우스 레지스트리에 해당.

manager

스웜 클러스터 전체를 제어하는 역할.

여러 대 실행되는 도커 호스트에 서비스가 담긴 컨테이너를 적절히 배치.

worker

실제 서비스 컨테이너들이 실행될 Host (책에서는 도커인도커 컨테이너)

manager컨테이너에 노드로 등록한다.

- 나머지 실습은 책 내용 참고

#### 도커 레지스트리에 이미지 등록하기

```shell
docker image tag example/echo:latest [레지스트리_호스트/]리파지토리명[:태그]
ex) docker image tag example/echo:latest localhost:5000/example/echo:latest
```

### 서비스

manager역활을 하는 컨테이너에서 docker service create명령으로 생성.

```shell
[docker container exec -it manager \]
docker service create --replicas 1 --publish 8000:8080 --name echo registry:5000/example/echo:latest
```

스케일 아웃

서비스가 스웜 클러스터의 노드를 분산배치함.

```shell
[docker container exec -it manager] docker service scale echo=6

# 스웜 클러스터 위에서 동작하는 컨테이너 확인
[docker container exec -it manager] docker service ps echo | grep Running
```

### 스택

하나 이상의 서비스를 그룹으로 묶은 단위, 애플리케이션 전체 구성을 정의.

서비스는 애플리케이션 이미지를 하나밖에 다루지 못하지만, 여러 서비스가 협조해 동작하는 형태로는 다양한 애플리케이션을 구성할 수 있다.

스택을 사용하면 여러 서비스를 함께 다룰 수 있다.

서비스는 이미지를 다루었다면 스택은 컴포즈를 다룬다.

스택은 말하자면 스웜에서 동작하는 스케일 인, 스케일 아웃, 제약 조건 부여가 가능한 컴포즈다.

스택을 사용해 배포된 서비스 그룹은 overlay네트워크에 속한다.

overlay 네트워크란 여러 도커 호스트에 걸쳐 배포된 컨테이너 그룹을 같은 네트워크에 배치하기 위한 기술을 말한다. (aws의 VPC생각하면 되려나..)

overlay 네트워크를 사용해야 서로 다른 호스트에 위치한 컨테이너끼리 통신할 수 있다.

스택에서 어떤 overlay 네트워크를 설정하지 않으면 스택마다 서로 다른 overlay 네트워크를 생성하고 그 안에 서비스 그룹이 속하게 된다.

overlay 네트워크 생성 명령어 (manager 컨테이너에서 수행)

```shell
[docker container exec -it manager] docker network create --driver=overlay --attachable ch03
```

#### 스택 배포하기

```shell
docker stack deploy [options] 스택명
-c: 스택_정의파일_경로

ex) [docker container exec -it manager] docker stack deploy -c /stack/ch03-webapi.yml echo
```

#### 배포된 스택 확인하기

```shell
docker stack services [options] 스택명

ex) [docker container exec -it manager] docker stack services echo
```

#### 스택에 배포된 컨테이너 확인하기

```shell
docker stack ps [options] 스택명

ex) [docker container exec -it manager] docker stack ps echo
```

#### 스택 삭제하기

```shell
docker stack rm

ex) [docker container exec -it manager] docker stack rm echo
```

#### visualizer를 사용해 컨테이너 배치 시각화하기

스웜 클러스터에 컨테이너 그룹이 어떤 노드에 어떻게 배치됐는지 시각화해주는 애필리케이션

도커 허브에서 dockersamples/visualizer 이미지 사용.

### 스웜 클러스터 외부에서 서비스 사용하기

외부에서 스웜 클러스터에 접근할때 애플리케이션이 여러 노드에 흩어져 배치되어 있기 때문에 서비스의 노드 위치를 고정하지 않는 이상 접근 할 수 없음.

따라서 서비스 클러스터 외부에서 오는 트래픽을 목적하는 서비스로 보내주는 프록시 서버가 필요함. → HAProxy 사용

## 공용 클라우드에서 스웜 클러스터에 노드 추가

AWS 또는 GCP와 같은 공용 클라우드에서 제공하는 오토 스케일 기능을 사용하면 스웜 클러스터에 쉽게 노드를 추가 할 수 있다.

1. worker Host와 동일한 환경과 스웜클러스터에 조인 하는 쉘스크립트를 만들어 놓은 Host 인스턴스 이미지를 떠놓는다.
2. 공용 클라우드가 제공하는 기능을 사용해 트래픽이 몰려 기존 Host의 CPU의 임계값을 넘으면 떠놓은 이미지를 이용해 자동으로 인스턴스를 추가 한 후 스웜클러스터에 조인하는 쉘 스크립트를 수행하도록 설정.
